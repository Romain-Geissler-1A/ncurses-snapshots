<HTML>
<HEAD>
<TITLE>Writing Programs with NCURSES</TITLE>
<link rev="made" href="mailto:esr@snark.thyrsus.com">
</HEAD>
<BODY>

<H1>Writing Programs with NCURSES</H1>

<BLOCKQUOTE>
by Zeyd M. ben-Halim and Eric S. Raymond<BR>
(version 1.9, 1 May 1995)
</BLOCKQUOTE>

<HR>
<H2>Introduction</H2>

This document is an introduction to programming with <TT>curses</TT>. It is 
not an exhaustive reference for the curses Application Programming Interface
(API); that role is filled by the <TT>curses</TT> manual pages.  Rather, it
is intended to help C programmers ease into using the package. <P>

The <TT>curses</TT> package is a subroutine library which presents a high level
screen model to the programmer, hiding differences between terminal types and
doing automatic optimization of output to change one screenfull of text into
another.  <TT>Curses</TT> uses terminfo, which is a database format that can
describe the capabilities of thousands of different terminals. <P>

Historically, the first ancestor of <TT>curses</TT> was the routines written to
provide screen-handling for the game <TT>rogue</TT>; these used the already-
existing <TT>termcap</TT> database facility for describing terminal
capabilities.  These routines were abstracted into a documented library and
first released with the early BSD UNIX versions. <P>

System III UNIX from Bell Labs featured a rewritten and much-improved
<TT>curses</TT> library.  It introduced the terminfo format.  Terminfo is based
on Berkeley's termcap database, but contains a number of improvements and
extensions. Parameterized capabilities strings were introduced, making it
possible to describe multiple video attributes, and colors and to handle far
more unusual terminals than possible with termcap.  In the later AT&amp;T
System V releases, <TT>curses</TT> evolved to use more facilities and offer
more capabilities, going far beyond BSD curses in power and flexibility.<P>

This document describes <TT>ncurses</TT>, a freeware implementation of the
System V <TT>curses</TT> API.  It includes the following System V curses
features: <P>
<UL>
<LI> Support for multiple screen highlights (BSD curses could only
handle one `standout' highlight, usually reverse-video). <P>
<LI> Support for line- and box-drawing using forms characters. <P>
<LI> Recognition of function keys on input. <P>
<LI> Color support. <P>
<LI> Support for pads (windows of larger than screen size on which the
screen or a subwindow defines a viewport). <P>
</UL>

Also, this package makes use of the insert and delete line and character
features of terminals so equipped, and determines how to optimally use these
features with no help from the programmer.  It allows arbitrary combinations of
video attributes to be displayed, even on terminals that leave ``magic
cookies'' on the screen to mark changes in attributes. <P>

The <TT>ncurses</TT> package was originated by Pavel Curtis.  The primary
maintainer of the package is Zeyd ben-Halim &lt;zmbenhal@netcom.com&gt;.
Eric S. Raymond &lt;esr@snark.thyrsus.com&gt; wrote many of the new
features in versions after 1.8.1 and coauthored this introduction. <P>

<H2>An Overview of the Package</H2>

<H3>Terminology</H3>

In this document, the following terminology is used with reasonable
consistency:

<DL>
<DT> window
<DD> 
A data structure describing a sub-rectangle of the screen (possibly the
entire screen).  You can write to a window as though it were a miniature
screen, scrolling independently of other windows on the physical screen.
<DT> screens
<DD> 
A subset of windows which are as large as the terminal screen, i.e., they start
at the upper left hand corner and encompass the lower right hand corner.  One
of these, <TT>stdscr</TT>, is automatically provided for the programmer.
<DT> terminal screen
<DD> 
The package's idea of what the terminal display currently looks like, i.e.,
what the user sees now.  This is a special screen.
</DL>

<H3>Compiling Programs using the Package</H3>

In order to use the library, it is necessary to have certain types and
variables defined.  Therefore, the programmer must have a line:

<PRE><TT>
	  #include &lt;curses.h&gt;
</TT></PRE>

at the top of the program source.  The screen package uses the Standard I/O
library, so <TT>&lt;curses.h&gt;</TT> includes
<TT>&lt;stdio.h&gt;</TT>. <TT>&lt;curses.h&gt;</TT> also includes
<TT>&lt;termios.h&gt;</TT>, <TT>&lt;termio.h&gt;</TT>, or
<TT>&lt;sgtty.h&gt;</TT> depending on your system.  It is redundant (but
harmless) for the programmer to do these includes, too. In linking with
<TT>curses</TT> you need to have <TT>-lncurses</TT> in your LDFLAGS or on the
command line.  There is no need for any other libraries.

<H3>Updating the Screen</H3>

In order to update the screen optimally, it is necessary for the routines to
know what the screen currently looks like and what the programmer wants it to
look like next. For this purpose, a data type (structure) named WINDOW is
defined which describes a window image to the routines, including its starting
position on the screen (the (y, x) coordinates of the upper left hand corner)
and its size.  One of these (called <TT>curscr</TT>, for current screen) is a
screen image of what the terminal currently looks like.  Another screen (called
<TT>stdscr</TT>, for standard screen) is provided by default to make changes
on. <P>

A window is a purely internal representation. It is used to build and store a
potential image of a portion of the terminal.  It doesn't bear any necessary
relation to what is really on the terminal screen; it's more like a
scratchpad or write buffer. <P>

To make the section of physical screen corresponding to a window reflect the
contents of the window structure, the routine <TT>refresh()</TT> (or
<TT>wrefresh()</TT> if the window is not <TT>stdscr</TT>) is called. <P>

A given physical screen section may be within the scope of any number of
overlapping windows.  Also, changes can be made to windows in any order,
without regard to motion efficiency.  Then, at will, the programmer can
effectively say ``make it look like this,'' and let the package implementation
determine the most efficient way to repaint the screen. <P>

<H3>Standard Windows and Function Naming Conventions</H3>

As hinted above, the routines can use several windows, but two are
automatically given: <TT>curscr</TT>, which knows what the terminal looks like,
and <TT>stdscr</TT>, which is what the pro- grammer wants the terminal to look
like next.  The user should never actually access <TT>curscr</TT> directly.
Changes should be made to through the API, and then the routine
<TT>refresh()</TT> (or <TT>wrefresh()</TT>) called. <P>

Many functions are defined to use <TT>stdscr</TT> as a default screen.  For
example, to add a character to <TT>stdscr</TT>, one calls <TT>addch()</TT> with
the desired character as argument.  To write to a different window. use the
routine <TT>waddch()</TT> (for `w'indow-specific addch()) is provided.  This
convention of prepending function names with a `w' when they are to be
applied to specific windows is consistent.  The only routines which do not
follow it are those for which a window must always be specified. <P>

In order to move the current (y, x) coordinates from one point to another, the
routines <TT>move()</TT> and <TT>wmove()</TT> are provided.  However, it is
often desirable to first move and then perform some I/O operation.  In order to
avoid clumsiness, most I/O routines can be preceded by the prefix 'mv' and
the desired (y, x) coordinates prepended to the arguments to the function.  For
example, the calls

<PRE><TT>
	  move(y, x);
	  addch(ch);
</TT></PRE>

can be replaced by

<PRE><TT>
	  mvaddch(y, x, ch);
</TT></PRE>

and

<PRE><TT>
	  wmove(win, y, x);
	  waddch(win, ch);
</TT></PRE>

can be replaced by

<PRE><TT>
	  mvwaddch(win, y, x, ch);
</TT></PRE>

Note that the window description pointer (win) comes before the added (y, x)
coordinates.  If a function requires a window pointer, it is always the first
parameter passed. <P>

<H2>Variables</H2>

The <TT>curses</TT> library sets some variables describing the terminal
capabilities.

<PRE><TT>
      type   name      description
      ------------------------------------------------------------------
      int    LINES     number of lines on the terminal
      int    COLS      number of columns on the terminal
</TT></PRE>

The <TT>curses.h</TT> also introduces some <TT>#define</TT> constants and types
of general usefulness:

<DL> 
<DT> <TT>bool</TT>
<DD> boolean type, actually a `char' (e.g., <TT>bool doneit;</TT>)
<DT> <TT>TRUE</TT>
<DD> boolean `true' flag (1).
<DT> <TT>FALSE</TT>
<DD> boolean `false' flag (0).
<DT> <TT>ERR</TT>
<DD> error flag returned by routines on a fail (-1).
<DT> <TT>OK</TT>
<DD> error flag returned by routines when things go right.
</DL>

<H2>Using the Library</H2>

Now we describe how to actually use the screen package.  In it, we assume all
updating, reading, etc. is applied to <TT>stdscr</TT>.  These instructions will
work on any window, providing you change the function names and parameters as
mentioned above. <P>

Here is a sample program to motivate the discussion: <P>

<PRE><TT>
#include &lt;curses.h&gt;
#include &lt;signal.h&gt;

static void finish(int sig);

main(int argc, char *argv[])
{
    /* initialize your non-curses data structures here */

    (void) signal(SIGINT, finish);      /* arrange interrupts to terminate */

    (void) initscr();      /* initialize the curses library */
    keypad(stdscr, TRUE);  /* enable keyboard mapping */
    (void) nonl();         /* tell curses not to do NL-&gt;CR/NL on output */
    (void) cbreak();       /* take input chars one at a time, no wait for \n */
    (void) noecho();       /* don't echo input */

    if (has_colors())
    {
        start_color();

        /*
         * Simple color assignment, often all we need.
         */
        init_pair(COLOR_BLACK, COLOR_BLACK, COLOR_BLACK);
        init_pair(COLOR_GREEN, COLOR_GREEN, COLOR_BLACK);
        init_pair(COLOR_RED, COLOR_RED, COLOR_BLACK);
        init_pair(COLOR_CYAN, COLOR_CYAN, COLOR_BLACK);
        init_pair(COLOR_WHITE, COLOR_WHITE, COLOR_BLACK);
        init_pair(COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLACK);
        init_pair(COLOR_BLUE, COLOR_BLUE, COLOR_BLACK);
        init_pair(COLOR_YELLOW, COLOR_YELLOW, COLOR_BLACK);
    }

    for (;;)
    {
        int c = getch();     /* accept a single keystroke of input */

        /* process the command keystroke */

        refresh();           /* repaint the screen */
    }

    finish(0);               /* we're done */
}

static void finish(int sig)
{
    endwin();

    /* do your non-curses wrapup here */

    exit(0);
}

</TT></PRE>

<H3>Starting up</H3>

In order to use the screen package, the routines must know about terminal
characteristics, and the space for <TT>curscr</TT> and <TT>stdscr</TT> must be
allocated.  These function <TT>initscr()</TT> does both these things. Since it
must allocate space for the windows, it can overflow memory when attempting to
do so. On the rare occasions this happens, <TT>initscr()</TT> will terminate
the program with an error message.  <TT>initscr()</TT> must always be called
before any of the routines which affect windows are used.  If it is not, the
program will core dump as soon as either <TT>curscr</TT> or <TT>stdscr</TT> are
referenced.  However, it is usually best to wait to call it until after you are
sure you will need it, like after checking for startup errors.  Terminal status
changing routines like <TT>nl()</TT> and <TT>cbreak()</TT> should be called
after <TT>initscr()</TT>. <P>

Once the screen windows have been allocated, you can set them up for
your program.  If you want to, say, allow a screen to scroll, use
<TT>scrollok()</TT>.  If you want the cursor to be left in place after
the last change, use <TT>leaveok()</TT>.  If this isn't done,
<TT>refresh()</TT> will move the cursor to the window's current (y, x)
coordinates after updating it. <P>

You can create new windows of your own using the functions <TT>newwin()</TT>,
<TT>derwin()</TT>, and <TT>subwin()</TT>.  The routine <TT>delwin()</TT> will
allow you to get rid of old windows.  All the options described above can be
applied to any window. <P>

<H3>Output</H3>

Now that we have set things up, we will want to actually update the terminal.
The basic functions used to change what will go on a window are
<TT>addch()</TT> and <TT>move()</TT>.  <TT>addch()</TT> adds a character at the
current (y, x) coordinates.  <TT>move()</TT> changes the current (y, x)
coordinates to whatever you want them to be.  It returns <TT>ERR</TT> if you
try to move off the window.  As mentioned above, you can combine the two into
<TT>mvaddch()</TT> to do both things at once. <P>

The other output functions, such as <TT>addstr()</TT> and <TT>printw()</TT>,
all call <TT>addch()</TT> to add characters to the window. <P>

After you have put on the window what you want there, when you want the portion
of the terminal covered by the window to be made to look like it, you must call
<TT>refresh()</TT>.  In order to optimize finding changes, <TT>refresh()</TT>
assumes that any part of the window not changed since the last
<TT>refresh()</TT> of that window has not been changed on the terminal, i.e.,
that you have not refreshed a portion of the terminal with an overlapping
window.  If this is not the case, the routine <TT>touchwin()</TT> is provided
to make it look like the entire window has been changed, thus making
<TT>refresh()</TT> check the whole subsection of the terminal for changes. <P>

If you call <TT>wrefresh()</TT> with <TT>curscr</TT> as its argument, it will
make the screen look like <TT>curscr</TT> thinks it looks like.  This is useful
for implementing a command which would redraw the screen in case it get messed
up. <P>

<H3>Input</H3>

The complementary function to <TT>addch()</TT> is <TT>getch()</TT> which, if
echo is set, will call <TT>addch()</TT> to echo the character.  Since the
screen package needs to know what is on the terminal at all times, if
characters are to be echoed, the tty must be in raw or cbreak mode.  Since
initially the terminal has echoing enabled and is in ordinary ``cooked'' mode,
one or the other has to changed before calling <TT>getch()</TT>; otherwise,
the program's output will be unpredictable. <P>

When you need to accept line-oriented input in a window, the functions
<TT>wgetstr</TT> and friends are available.  There is even a <TT>wscanw</TT>
function that can do <TT>scanf</TT>(3)-style multi-field parsing on window
input.  These pseudo-line-oriented functions turn on echoing while they
execute. <P>

The example code above uses the call <TT>keypad(stdscr, TRUE)</TT> to enable
support for function-key mapping.  With this feature, the <TT>getch()</TT> code
watches the input stream for character sequences that correspond to arrow and
function keys.  These sequences are returned as pseudo-character values.  The
<TT>#define</TT> values returned are listed in the <TT>ncurses.h</TT> The
mapping from sequences to <TT>#define</TT> values is determined by
<TT>key_</TT> capabilities in the terminal's terminfo entry. <P>

<H3>Using Forms Characters</H3>

The <TT>addch</TT> function (and some others, including <TT>box</TT> and
<TT>border</TT>) can accept some pseudo-character arguments which are specially
defined by <TT>ncurses</TT>.  These are <TT>#define</TT> values set up in
the <TT>ncurses.h</TT> header; see there for a complete list (look for
the prefix <TT>ACS_</TT>). <P>

The most useful of the ACS defines are the forms-drawing characters.  You can
use these to draw boxes and simple graphs on the screen.  If the terminal
does not have such characters, <TT>ncurses.h</TT> will map them to a
recognizable (though ugly) set of ASCII defaults. <P>

<H3>Character Attributes and Color</H3>

The <TT>ncurses.h</TT> package supports screen highlights including standout,
reverse-video, underline, and blink.  It also supports color, which is treated
as another kind of highlight. <P>

Highlights are encoded, internally, as high bits of the pseudo-character type
(<TT>chtype</TT>) that <TT>ncurses.h</TT> uses to represent the contents of a
screen cell.  See the <TT>ncurses.h</TT> header file for a complete list of
highlight mask values (look for the prefix <TT>A_</TT>).<P>

There are two ways to make highlights.  One is to logical-or the value of the
highlights you want into the character argument of an <TT>addch</TT> call,
or any other output call that takes a <TT>chtype</TT> argument. <P>

The other is to set the current-highlight value.  This is logical-or'ed with
any highlight you specify the first way.  You do this with the functions
<TT>attron</TT>, <TT>attroff</TT>, and <TT>attrset</TT>; see the manual
pages for details.

Color is a special kind of highlight.  The package actually thinks in terms
of color pairs, combinations of foreground and background colors.  The sample
code above sets up eight color pairs, all of the guaranteed-available colors
on black.  Note that each color pair is, in effect, given the name of its
foreground color.  Any other range of eight non-conflicting values could
have been used as the first arguments of the <TT>init_pair</TT> values. <P>

Once you've done an <TT>init_pair</TT> that creates color-pair N, you can
use <TT>COLOR_PAIR(N)</TT> as a highlight that invokes that particular
color combination.  Note that <TT>COLOR_PAIR(N)</TT>, for constant N,
is itself a compile-time constant and can be used in initializers. <P>

<H3>Finishing Up</H3>

In order to clean up after the <TT>ncurses</TT> routines, the routine
<TT>endwin()</TT> is provided.  It restores tty modes to what they were when
<TT>initscr()</TT> was first called, and moves the cursor down to the
lower-left corner.  Thus, anytime after the call to initscr, <TT>endwin()</TT>
should be called before exiting. <P>

<H2>Hints, Tips, and Tricks</H2>

The <TT>ncurses</TT> manual pages are a complete reference for this library.
In the remainder of this document, we discuss various useful methods that
may not be obvious from the manual page descriptions. <P>

<H3>Some Notes of Caution</H3>

Bear in mind that <TT>refresh()</TT> is a synonym for
<TT>wrefresh(stdscr)</TT>,
and don't try to mix use of <TT>stdscr</TT> with use of windows declared
by <TT>newwin</TT>; a <TT>refresh()</TT> call will blow them off the
screen.  The right way to handle this is to use <TT>subwin</TT>, or
not touch <TT>stdscr</TT> at all and tile your screen with declared
windows which you then <TT>wnoutrefresh<TT> somewhere in your program
event loop, with a single <TT>doupdate</TT> call to trigger actual
repainting. <P>

You are much less likely to run into problems if you design your screen
layouts to use tiled rather than overlapping windows.  Historically,
curses support for overlapping windows has been weak, fragile, and poorly
documented.  The <TT>ncurses</TT> library is not yet an exception to this
rule. <P>

There is a freeware panels library included in the <TT>ncurses</TT>
distribution that does a pretty good job of strengthening the
overlapping-windows facilities. <P>

Try to avoid using the global variables LINES and COLS.  Use
<TT>getmaxyx()</TT> on the <TT>stdscr</TT> context instead.  Reason:
your code may be ported to run in an environment with window resizes,
in which case several screens could be open with different sizes. <P>

<H3>Temporarily Leaving <TT>ncurses</TT> Mode</H3>

Sometimes you will want to write a program that spends most of its time in
screen mode, but occasionally returns to ordinary `cooked' mode.  A common
reason for this is to support shell-out.  This behavior is simple to arrange
in <TT>ncurses</TT>. <P>

To leave <TT>ncurses</TT> mode, call <TT>endwin()</TT> as you would if you
were intending to terminate the program.  This will take the screen back to
cooked mode; you can do your shell-out.  When you want to return to
<TT>ncurses</TT> mode, simply call <TT>refresh()</TT>.  This will repaint
the screen. <P>

There is a boolean function, <TT>isendwin()</TT>, which code can use to
test whether <TT>ncurses</TT> screen mode is active.  It returns <TT>TRUE</TT>
in the interval between an <TT>endwin()</TT> call and the following
<TT>refresh()</TT>, <TT>FALSE</TT> otherwise.  <P>

<H3>Using <TT>ncurses</TT> With X</H3>

A resize operation in X sends SIGWINCH to the running application.  The
<TT>ncurses</TT> library does not catch this signal, because it cannot in
general know how you want the screen re-painted.  You will have to write
the SIGWINCH handler yourself. <P>

At the moment, <TT>ncurses</TT> has no hooks that are specialized to
help you do this, though future versions will probably have them. <P>

At minimum, your SIGWINCH handler should do a <TT>clearok()</TT>, followed by a
<TT>wrefresh()</TT> on each of your windows (or, equivalently but more
efficiently, <TT>wnoutrefresh()</TT> on each one followed by
<TT>doupdate()</TT>). <P>

<H3>Handling Multiple Terminal Screens</H3>

The <TT>initscr()</TT> function actually calls a function named
<TT>newterm()</TT> to do most of its work.  If you are writing a program that
opens multiple terminals, use <TT>newterm()</TT> directly. <P>

For each call, you will have to specify a terminal type and a pair of file
pointers; each call will return a screen reference, and <TT>stdscr</TT> will be
set to the last one allocated.  You will switch between screens with the
<TT>set_term</TT> call.  Note that you will also have to call
<TT>def_shell_mode</TT> and <TT>def_prog_mode</TT> on each tty yourself. <P>

<H3>Testing for Terminal Capabilities</H3>

Sometimes you may want to write programs that test for the presence of various
capabilities before deciding whether to go into <TT>ncurses</TT> mode.  An easy
way to do this is to call <TT>setupterm()</TT>, then use the functions
<TT>tigetflag()</TT>, <TT>tigetnum()</TT>, and <TT>tigetstr()</TT> to do your
testing. <P>

<H3>Tuning for Speed</H3>

Use the <TT>addchstr()</TT> family of functions for fast
screen-painting of text when you know the text doesn't contain any
control characters.  Try to make attribute changes infrequent on your
screens.  Don't use the <TT>immedok()</TT> option! <P>

<H2>Special Features of NCURSES</H2>

When running on PC-clones, <TT>ncurses</TT> has enhanced support for the
IBM high-half and ROM characters.  The ACS forms characters default not to
the ugly ASCII makeshifts but to a set picked out of the IBM high-half and
ROM graphics.  A new highlight, <TT>A_PCCHARSET</TT>, enables display of the
PC ROM graphics 0-31 that are normally interpreted as control characters.

<HR>
<ADDRESS>Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;</ADDRESS>
</BODY>
</HTML>

