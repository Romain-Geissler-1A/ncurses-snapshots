/******************************************************************************
 * Copyright 1997 by Thomas E. Dickey <dickey@clark.net>                      *
 * All Rights Reserved.                                                       *
 *                                                                            *
 * Permission to use, copy, modify, and distribute this software and its      *
 * documentation for any purpose and without fee is hereby granted, provided  *
 * that the above copyright notice appear in all copies and that both that    *
 * copyright notice and this permission notice appear in supporting           *
 * documentation, and that the name of the above listed copyright holder(s)   *
 * not be used in advertising or publicity pertaining to distribution of the  *
 * software without specific, written prior permission. THE ABOVE LISTED      *
 * COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  *
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO     *
 * EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY         *
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER       *
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF       *
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN        *
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.                   *
 ******************************************************************************/

/*
 * This replaces an awk script which translated keys.list into keys.tries by
 * making the output show the indices into the TERMTYPE Strings array.  Doing
 * it that way lets us cut down on the size of the init_keytry() function.
 */
#include <curses.priv.h>

MODULE_ID("$Id: make_keys.c,v 1.1 1997/06/15 18:02:08 tom Exp $")

#include <names.c>

static size_t lookup(const char *name)
{
	size_t n;
	bool found = FALSE;
	for (n = 0; n < SIZEOF(strnames)-1; n++) {
		if (!strcmp(name, strnames[n])) {
			found = TRUE;
			break;
		}
	}
	if (!found) {
		for (n = 0; n < SIZEOF(strfnames)-1; n++) {
			if (!strcmp(name, strfnames[n])) {
				found = TRUE;
				break;
			}
		}
	}
	return n;
}

static void make_keys(FILE *ifp, FILE *ofp)
{
	char buffer[BUFSIZ];
	char from[BUFSIZ];
	char to[BUFSIZ];
	int maxlen = 16;

	while (fgets(buffer, sizeof(buffer), ifp) != 0) {
		if (sscanf(buffer, "%s %s", from, to) == 2) {
			if ((int)strlen(from) > maxlen)
				maxlen = strlen(from);
			fprintf(ofp, "\t{ %4d, %-*.*s },\t/* %s */\n",
				lookup(from),
				maxlen, maxlen,
				to,
				from);
		}
	}
}

static void write_list(FILE *ofp, const char **list)
{
	while (*list != 0)
		fprintf(ofp, "%s\n", *list++);
}

int main(int argc, char *argv[])
{
	static const char *prefix[] = {
		"#ifndef NCU_KEYS_H",
		"#define NCU_KEYS_H 1",
		"",
		"/* This file was generated by MAKE_KEYS */",
		"",
		"static const struct {",
		"\tunsigned offset;",
		"\tchtype code;",
		"} table[] = {",
		0
	};
	static const char *suffix[] = {
		"};",
		"",
		"#endif /* NCU_KEYS_H */",
		0
	};

	write_list(stdout, prefix);
	if (argc > 1) {
		int n;
		for (n = 1; n < argc; n++) {
			FILE *fp = fopen(argv[n], "r");
			if (fp != 0) {
				make_keys(fp, stdout);
				fclose(fp);
			}
		}
	} else {
		make_keys(stdin, stdout);
	}
	write_list(stdout, suffix);
	return EXIT_SUCCESS;
}
